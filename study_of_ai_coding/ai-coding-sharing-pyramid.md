# AI Coding 内部分享：如何AI Coding

> 基于**金字塔原理**（结论先行、以上统下、归类分组、逻辑递进）整理

---

## 📌 核心结论

**AI Coding = 工具体系 × 工作方法论 × 角色转型**

掌握AI Coding需要三个维度的系统性升级：
- **工具体系**：从单一工具到多模型Agent编排
- **工作方法论**：从Vibe Coding到Spec Driven开发  
- **角色转型**：从代码实现者到AI技术导师

**价值**：2-5倍真实效率提升 + 质量可控

---

## 目录

- [第一部分：AI Coding工具体系演进](#第一部分ai-coding工具体系演进)
- [第二部分：AI Coding工作方法论](#第二部分ai-coding工作方法论)
- [第三部分：AI Coding角色转型](#第三部分ai-coding角色转型)
- [第四部分：实战案例](#第四部分实战案例)
- [第五部分：行动建议](#第五部分行动建议)

---

## AI 编程工具简介

1. 代码补全工具
2. IDE插件
3. AI原生IDE
4. 终端AI编程工具（CLI）


### 1.1 代码补全工具

- GitHub Copilot
- 通义灵码

**适用场景**：
- ✅ 日常编码补全
- ✅ 函数/方法实现
- ✅ 代码片段生成

**局限性**：
- ❌ 无自主性，需要明确引导
- ❌ 无法处理复杂多文件任务
- ❌ 缺少系统级理解能力


### 1.2 IDE插件

- Cline
- Codefuse
- Aone

**优势**：
- ✅ 支持AI对话驱动代码编辑
- ✅ 工具集成（常用bash、mcp、ide能力集成）

**局限性**：
- ❌ 与AI交互受限



### 1.3 AI原生IDE
大部分基于VSCode二次开发

- Cursor
  https://cursor.com/cn
- Antigravity
  https://antigravity.google/
- Qoder
  https://caug.cn/
- Trae
  https://www.trae.cn/
- CodeBuddy
  https://www.codebuddy.com/

**优势**：
- ✅ 从AI视角出发，更强调指挥AI。

**局限性**：
- ❌ 学习成本较高，存在从现有IDE迁移成本

### 1.4 终端AI编程工具（CLI）

- Claude code
  https://claude.com/product/claude-code
- Codex
  https://openai.com/zh-Hans-CN/index/introducing-upgrades-to-codex/
- gemini cli
  https://geminicli.com/
- opencode
  https://opencode.ai/
  目前个人最常用，站在CC之上。


**优势**：
- ✅ 轻量化
- ✅ 灵活性高，社区生态好

**局限性**：
- ❌ 对于不习惯终端的用户交互不友好


没有绝对的好与坏，看场景



## 构建agent和常见问题

### 构建coding agent

大语言模型的工作方式可以用一句话概括：**基于输入预测下一个 token。**

在常见的大预言模型上，通过以下方式组合成agent
1. 强化学习。通过尝试 → 反馈 → 调整的RL，让模型的结果从看起来对到做起来对。
2. 保留Reasoning思考内容。保留在多轮对话中。
3. 提示词缓存。每轮的提示词尽量满足前缀匹配的组装顺序，尽量命中缓存。
4. 执行循环。
5. 工具
	1. 文件/目录搜索
	2. 文件读写
	3. bash执行文件



### 使用agent工具时的常见问题

#### 上下文窗口耗尽

模型在基于上下文内容来预测token时（注意力机制），往往有下面几个特性：
 1. **有效上下文比标称小很多**：模型不会均匀地关注所有内容。在实践中，Attention 权重往往集中在少数关键位置，大部分位置的权重接近于零。
 2. **权重分布往往有偏好**：模型通过训练学习在什么情况下关注什么内容。这意味着它可能会形成某些偏好模式，比如更关注开头和结尾。
 3. **上下文很难做长**：标准 Attention 需要计算每个位置与所有其他位置的关系，计算量随上下文长度的平方增长，计算复杂度是平方级的。这是上下文长度存在物理上限的根本原因之一。

如果上下文问题不解决，执行再长也是越写越烂。

#### 会话记忆丢失
开发者没有主动将项目维度的信息写入长期记忆中。导致记忆只存在于单个session中，每次执行任务增加了初始获取信息的时间成本，上下文成本，试错成本。

开启新会话的目的就是想拥有一个全新的上下文窗口。但是有些session中信息是具备可复用性的。


#### 过早宣告成功
经常出现多轮行动后，提前宣布任务都完成了。
我理解导致的原因也是和注意力机制的权重分布有关。



## Claude code简介

以最常用的coding agent，claude code来举例。从他为使用者提供的功能上来，他在最基础的agent之上解决哪些问题。


### 简介
Claude Code(CC)是由 Anthropic 开发的，本地命令行交互形态的AI agent。它从编程视角出发，具备基础的bash工具能力，拥有丰富的提示词复用和上下文管理功能，以及活跃的插件生态。

选择cc的理由：
1. 交互简约。交互体验轻量化。
2. 能力简约。功能简约且强大。
3. 拓展性。插件社区活跃。
4. 被市场验证。被大部分其他的ai coding工具对标和借鉴，走在前沿。

我现在用的更多的是opencode.开源的力量很强大，功能上紧追不舍，终端体验超越，有更激进的功能，生态上更丰富(兼容cc)。

当然现在业界的工具水平大差不差。选择适合自己的，更多的是了解到底是哪些环节可能会导致效果不好。

### 常用功能


#### 全局规则
CLAUDE.md
长期记忆（跨session）


#### 斜杠命令
提示词复用。
主动调起预设提示词指令复用


#### subagent
创建agent实例，开启子会话。核心是隔离上下文


#### skills
Anthropic定义的skills就是智能体可以识别的可复用资产。体现的载体是由指令、脚本和资源组成的文件夹，以及agent具备使用bash工具的能力。
特点：
1. 分段懒加载（渐进式披露）。从上下文角度看就是分段懒加载。从检索角度看就是分级索引检索。
2. 文件夹。内容白盒，构建灵活。
	1. 可读取，可执行。


提炼出来的skills本身很简约，可读性很高。而A的适配层同样很简约。所有的功能都是建立在文件系统和bash命令之上，agent自主决定，并没有在最初的设计上冗余和魔改。也说明了，这个系统最初设计的通用性。

完整的skill是施展在沙箱环境之上的。编程是非常广泛的工程领域，成果相对容易验证，领域方法论成熟并且广泛，是skill应用最多的领域。


#### Plugins 
上述配置打包在一起。


## 优化思路

在有了简单好用的coding agent之后，对于提供的功能还要探索，如何使用，挖掘最大潜力。

- 还是会乱写
- 还是会出错
- 还是会不长记性

从下面这几个方面，再去考虑还需要做什么

### 上下文管理

#### 精简内容

会话里
##### 遮蔽
移除无用信息。比如很多工具的返回都是冗余的。
例如使用head tail等等这些查看部分的工具来替代读取整个文件

##### 压缩
- 总结摘要。
- 总结摘要同时，将详细信息卸载，用索引相关机制来关联。

前者是有损的，数据是一定会丢失的。后者更好的保护现场，具备溯源的可能性，随着模型能力提升，是够具备潜力的。

##### 动态装卸载

动态装载，渐进式披露，懒加载
最常见的应用就是skills
两种方式，工程上直接装载，比如工具信息，全局规则(长期记忆)等等。模型自装载，比如skills的内容，spec文档等等。

动态卸载
解决在清理会话上下文时也能够保留，高质量或者可溯源的上下文内容。
常见的应用有，写入长期记忆，沉淀为可复用文件等等

将更多的上下文内容都组织成可以渐进式披露的形式。可以是全局规则中的文件分层索引，也可以是skills。


会话间
##### 隔离
subagent、新session

涉及到新的问题，隔离之后，如何高效通信和交互。

直接探索
沙箱模糊了一部分上下文系统和项目本身。
1. 用项目代码本身去交互
	1. 本身写代码，和我们开发者写代码一样。代码本身不只是跑业务，也是为了告诉后续开发者我的实现思路，本身就有一定的沟通交流的含义在。就像简介代码里讲的，代码要可以自解释。如果代码不可读，起码从软件工程角度以及长期来说，他不是高效率的好代码。
	2. 只不过每一个空的上下文介入时，需要一个检索收集过程，这个过程针对的是整个项目代码。


系统有一个探索的预期，或者也可以说是重新加载(动态)上下文


#### 提升质量

开始前澄清所有细节。
先计划好再实施。其中计划包含大量人类结束，来减少随机性




#### 软件工程、架构方法、开发范式
传统方法本身也是为了提高项目的迭代效率以及可读性可维护性。和上下文管理效率不谋而合。

我觉得本质上都在从这几个方面来保证对于一个工程项目问题的，
- 子问题拆分
- 流程约束
- 沉淀可复用资产





拆分子问题
	- 深度、广度
- 先澄清后实施
- 可复用


##### claude code 的plan模式

1. 使用plan模式，这个为只读，并且只能创建和澄清需求计划。计划文件存储在默认路径文件内。
2. 从plan模式切换到正常模式，根据当前会话的最新计划进行实施。


##### SDD插件

规范驱动开发（Spec-Driven Development, SDD）
SDD
SDD插件
B
speckit

##### SpecKit：工程化治理框架
**定位**：GitHub开源的规范驱动开发框架

**官网**：https://github.com/github/spec-kit

核心观点：
```
规范即代码 → 规范直接生成实现，而非仅作为指导文档
权力倒置 → 代码服务于规范，而非规范服务于代码
测试优先 → 强制 TDD，不可协商地要求先写测试
```

核心流程：
```
Constitution → Specify → Plan → Tasks → Implement   (宪章)      (规范)    (计划)  (任务)   (实施)
```

**七步工作流**：
```bash
/speckit.constitution  → 定义治理原则（九条宪章）
/speckit.specify      → 创建功能规范（spec.md）
/speckit.clarify      → 需求澄清（更新spec.md）
/speckit.plan         → 生成技术方案（plan.md, research.md, data-model.md）
/speckit.analyze      → 一致性校验（分析报告）
/speckit.tasks        → 任务分解（tasks.md）
/speckit.implement    → 执行实现（代码与测试）
```

**九条宪章质量门控**：
| 条款 | 名称 | 约束类型 | 影响 |
|------|------|---------|------|
| I | Library-First原则 | 塑造性 | 指导架构设计 |
| II | CLI接口强制 | 塑造性 | 要求命令行接口 |
| III | 测试优先开发 | 塑造性 | 强制TDD |
| IV | 文档优先 | 塑造性 | 实现前需完善文档 |
| V | 功能隔离 | 塑造性 | 强制关注点分离 |
| VI | 版本控制规范 | 塑造性 | 强制Git工作流 |
| VII | 简约门控 | 前置门控 | 复杂度控制 |
| VIII | 反抽象门控 | 前置门控 | 禁止过度抽象 |
| IX | 集成优先门控 | 前置门控 | 缺少测试阻断 |

##### OpenSpec：轻量化审计工具

轻量级、可审计的规范管理工具

https://github.com/Fission-AI/OpenSpec


**核心思想**：
- **可对齐性**：人机共享同一份规格文件
- **轻量与可移植性**：完全本地化，便于版本控制
- **透明与可审计性**：每次变更产生明确的delta文件
- **AI原生协作**：支持多种AI工具
- **零依赖运行**：无需API Key，离线可用

核心流程：

```
┌────────────────────┐
│ 起草变更提案       │
│ (Draft Change      │
│  Proposal)         │
└────────┬───────────┘
         │ 与 AI 共享意图
         ▼
┌────────────────────┐
│ 评审与对齐         │
│ (Review & Align)   │◀──── 反馈循环 ──────┐
│ (编辑规格/任务)    │                     │
└────────┬───────────┘                     │
         │ 获批方案                          │
         ▼                                   │
┌────────────────────┐                      │
│ 执行任务           │──────────────────────┘
│ (AI 编写代码)      │
└────────┬───────────┘
         │ 发布变更
         ▼
┌────────────────────┐
│ 归档并更新         │
│ 规格 (源文档)      │
└────────────────────┘

1. 起草一份变更提案，记录你想要的规格更新。
2. 与你的 AI 助手一起评审提案，直到达成一致。
3. 实施引用已确认规格的任务。
4. 归档变更，将已批准的更新合并回“唯一真实来源”的规格文档。
```

**Delta格式示例**：
```markdown
# Delta Specs: 用户认证功能

## ADDED Requirements
- 用户必须能够通过用户名和密码注册
- 用户必须能够通过用户名和密码登录
- 登录成功后返回JWT token

## ADDED API Endpoints
- POST /api/auth/register
- POST /api/auth/login
- POST /api/auth/refresh

## ADDED Security Requirements
- 密码必须使用bcrypt加密（salt: 10）
- Token必须包含过期时间
- 必须实现rate limiting
```

openspec 的 Delta 机制设计得很巧妙：不同于直接存储完整的"未来状态"，它只存储**变更操作**本身（ADDED/MODIFIED/REMOVED/RENAMED）。归档时通过语义名称匹配来定位需求，避免了 Git Merge 常见的位置冲突问题。同时采用 Fail-Fast 机制，在写入前做完整冲突检测，保证不会产生半完成状态。


**都指向同一个目标：让 AI 编程更可控、更规范。**


opencode




##### 任务委派/会话隔离


子代理驱动

oh-my-opencode
https://github.com/code-yeongyu/oh-my-opencode/blob/dev/README.zh-cn.md

opencode插件，功能配置集合。包含6个agent

核心思量

轻量化开发工作流插件superpowers中的子代理驱动skills
https://github.com/obra/superpowers


fork新会话，基于文档交互

使用SDD将信息从上下文卸载后，创建新会话


superpowers中的








#### 不要过多约束
相对少的影响细节控制，比如命名。限定大的框架。





### 复利工程（Compounding Engineering）


从经验复用的角度看上下文管理，强调在ai coding中应该做好系统的长期记忆。
核心思想：
每次ai做事，都会让下一次ai做得更好。

把ai coding相关的经验沉淀下来
1. ai coding中的问题排查和解决
2. 开发者使用工具提示词、工具配置、插件配置等等
3. 





将经验（长期记忆）沉淀下来。

形式可以采用规则文件，skills等方式





#### 复用内容
分类
1. 踩坑修复。
2. 方案选型。应用COLA结构。存储接口定义应该在domain层。写es实现应该放在基础设施层。junit使用4版本
3. 高频问答。


#### 实现载体
1. 规则文件(AGENTS.md)
2. skills(本地文件)
3. mcp + 后端
4. 混合


#### 复用时机
1. 出现错误
2. review

如何实现，工具自带，检索方式定义在全局规则，hook，subagent规则等等
加载过程尽量不要占用主agent，规划阶段使用skill懒加载，review阶段使用hook+subagent+skill会话隔离




代码本身也是经验


参考cc之父工作流
740 万围观！Claude Code 之父的工作流火了 740 万围... http://xhslink.com/o/2WnLEAbiXoq 
复制后打开【小红书】查看笔记！


### 总结共识

各家在不同维度，不同产品形态dou

- 上下文是稀缺的。
	- 像对待内存一样对待上下文
- 文件系统是简单高效的。
	- 可以低成本的存储和读取，可以
- 卸载很关键。
	- 当前不用了，或者为了其他会话准备，就需要及时卸载出来。就像内存数据持久化到硬盘。
	- 短期内，虽然上下文或者内存不断提升，这种机制可以用来平衡成本，并且在不同规模下都是合理高效的。
- 默认不给，按需加载。
	- 可以依赖agentic能力，可以工程化。为了减少上下文污染。



### 我理解的当前最好的实践

最好的模型，适当的问题分解和隔离，

新东西很多很快。优先做好那些看起来最稳定的


## coding配置分享




## skill的使用



## 相关分享

### vibe kanban
用看板的形式，驱动ai coding项目
![[Pasted image 20260122195916.png]]
https://github.com/BloopAI/vibe-kanban


### happy
Claude Code/Codex的移动端
![[Pasted image 20260122200132.png]]
https://github.com/slopus/happy




## 角色转变


| 维度        | 乙方时代（传统编程） | 甲方时代（Vibe Coding） | 导师时代（Agentic Coding） |
| --------- | ---------- | ----------------- | -------------------- |
| **核心工作**  | 编写代码       | 提出需求              | 计划 + 实施 + 验收 + 复利    |
| **与AI关系** | 无AI        | 模糊指挥              | 技术导师                 |
| **质量保障**  | 个人能力       | 缺失                | 严格审查                 |
| **效率水平**  | 1x         | 伪高效率              | 2-5x真效率              |

## 总结

AI Coding = 工具体系 × 工作方法论 × 角色转型
